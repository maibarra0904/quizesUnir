export const metodologias = [
    {
        question: "¿Qué es la Ingeniería de Software?",
        options: {
            A: "Es una metodología para desarrollar software de calidad.",
            B: "Es una disciplina que permite desarrollar software de calidad.",
            C: "Es una disciplina que solo contempla el desarrollo del software, pero no su mantenimiento.",
            D: "Es una metodología que contempla todo el proceso de producción del software."
        },
        answer: "B",
        detail: "Es una disciplina que permite desarrollar software de calidad."
    },
    {
        question: "A la hora de desarrollar un producto software:",
        options: {
            A: "Hasta que no se termina el diseño jamás se empieza con la codificación.",
            B: "No se hace ninguna estimación.",
            C: "Diseño y codificación pueden solaparse en el tiempo.",
            D: "No se tiene en cuenta el entorno en el que va a funcionar."
        },
        answer: "C",
        detail: "Diseño y codificación pueden solaparse en el tiempo."
    },
    {
        question: "Señala la respuesta correcta sobre las características de un producto software:",
        options: {
            A: "Es algo tangible.",
            B: "No evoluciona con el tiempo.",
            C: "Los cambios en el software pueden tener efectos colaterales.",
            D: "Ninguna de las respuestas anteriores es correcta."
        },
        answer: "C",
        detail: "Los cambios en el software pueden tener efectos colaterales."
    },
    {
        question: "¿Qué afirmación tiene relación con la crisis del software?",
        options: {
            A: "Las empresas ya no tienen tanta necesidad de productos software y hay crisis en el sector.",
            B: "El software tiene una calidad muy baja, pero cumple con las planificaciones realizadas.",
            C: "Los proyectos software no cumplen con las planificaciones realizadas.",
            D: "El software tiene una alta calidad y está alineado con el negocio."
        },
        answer: "C",
        detail: "Los proyectos software no cumplen con las planificaciones realizadas."
    },
    {
        question: "¿Qué es un artefacto software?",
        options: {
            A: "Pieza de información que se produce o se utiliza en un proceso de desarrollo de software.",
            B: "Cada una de las etapas que se dan un proceso de desarrollo de software.",
            C: "Fecha de referencia en una etapa dentro del proceso de desarrollo de software.",
            D: "Ninguna de las definiciones anteriores es correcta."
        },
        answer: "A",
        detail: "Pieza de información que se produce o se utiliza en un proceso de desarrollo de software."
    },
    {
        question: "¿Qué define un proceso?",
        options: {
            A: "Un proceso define quién está haciendo qué, cuándo, y cómo para alcanzar un determinado objetivo.",
            B: "Un proceso define quién está haciendo qué, pero no cuándo ni cómo.",
            C: "Un proceso define quién está haciendo qué, cuándo, pero no cómo.",
            D: "Un proceso no define los pasos a seguir para desarrollar software."
        },
        answer: "A",
        detail: "Un proceso define quién está haciendo qué, cuándo, y cómo para alcanzar un determinado objetivo."
    },
    {
        question: "El objetivo principal del proceso de desarrollo de software es:",
        options: {
            A: "Reducir el coste del proyecto.",
            B: "Gestionar los recursos humanos del proyecto.",
            C: "Mejorar la forma de trabajar a la hora de desarrollar software, favoreciendo la prevención de posibles problemas que puedan surgir.",
            D: "Reducir el tiempo de desarrollo de un proyecto."
        },
        answer: "C",
        detail: "Mejorar la forma de trabajar a la hora de desarrollar software, favoreciendo la prevención de posibles problemas que puedan surgir."
    },
    {
        question: "¿Qué es un modelo de proceso software?",
        options: {
            A: "Un modelo de proceso de desarrollo de software es un prototipo del sistema a desarrollar.",
            B: "Un modelo de proceso de desarrollo de software es el proceso de desarrollo específico que se aplica en un proyecto software determinado.",
            C: "Un modelo de proceso de desarrollo de software es una descripción detallada del sistema a implementar.",
            D: "Un modelo de proceso de software es una representación simplificada de un proceso de desarrollo software real."
        },
        answer: "D",
        detail: "Un modelo de proceso de software es una representación simplificada de un proceso de desarrollo software real."
    },
    {
        question: "El modelo en espiral:",
        options: {
            A: "Es iterativo e incremental.",
            B: "Es equivalente al modelo en cascada.",
            C: "No contempla los riesgos del proyecto.",
            D: "No contempla el desarrollo de prototipos."
        },
        answer: "A",
        detail: "Es iterativo e incremental."
    },
    {
        question: "¿Cuáles de los siguientes pueden ser stakeholders de un producto o proyecto?",
        options: {
            A: "Un experto en el dominio.",
            B: "Un ministerio que establece regulaciones sobre productos y servicios.",
            C: "Un usuario final.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "D",
        detail: "Todas las respuestas anteriores son correctas."
    },
    {
        question: "¿Cuál de estas no es una característica principal de las técnicas tradicionales?",
        options: {
            A: "Son técnicas predictivas.",
            B: "Se basan en una planificación detallada y en un contrato estricto.",
            C: "Se adaptan rápidamente al cambio.",
            D: "Se basan en poca documentación y en un trabajo colectivo."
        },
        answer: "C",
        detail: "Se adaptan rápidamente al cambio."
    },
    {
        question: "¿Cuál de las siguientes es una característica clave del proceso unificado?",
        options: {
            A: "Está centrado en la arquitectura.",
            B: "Sigue un modelo iterativo e incremental.",
            C: "Está dirigido por casos de uso.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "D",
        detail: "Todas las respuestas anteriores son correctas."
    },
    {
        question: "Uno de los modelos más importantes en la fase de inicio del proceso unificado es:",
        options: {
            A: "El modelo de dominio.",
            B: "El modelo de clases de diseño.",
            C: "El modelo de componentes.",
            D: "El modelo de interacción."
        },
        answer: "A",
        detail: "El modelo de dominio."
    },
    {
        question: "¿Bajo qué perspectivas se trabaja en RUP?",
        options: {
            A: "Estática, dinámica y estética.",
            B: "Estática, práctica e incremental.",
            C: "Estática, práctica y dinámica.",
            D: "Dinámica, práctica, estética e incremental."
        },
        answer: "C",
        detail: "Estática, práctica y dinámica."
    },
    {
        question: "El proceso unificado de rational:",
        options: {
            A: "Únicamente tiene en cuenta una perspectiva estática y otra dinámica.",
            B: "Es una mejora con respecto al essential unified process (EssUP).",
            C: "Implementa el software en base a artefactos.",
            D: "Implementa el software reutilizando componentes."
        },
        answer: "C",
        detail: "Implementa el software en base a artefactos."
    },
    {
        question: "El objetivo del proceso de diseño del sistema de Información, en métrica v.3, es la obtención de un marco de referencia para el desarrollo de sistemas de información que responda a los objetivos estratégicos de la organización:",
        options: {
            A: "Verdadero.",
            B: "Falso.",
            C: "Verdadero, en el caso de que no fuera preciso realizar el estudio de viabilidad.",
            D: "Falso, solo en el caso en el que no haya objetivos estratégicos."
        },
        answer: "B",
        detail: "Falso."
    },
    {
        question: "¿Cuál es el objetivo principal del proceso de Implantación y aceptación del sistema en métrica v.3?",
        options: {
            A: "La entrega y aceptación del sistema de una parte concreta.",
            B: "Estudiar la visión de los usuarios previamente a la entrega del sistema.",
            C: "La entrega y aceptación del sistema en su totalidad y realizar el paso a producción.",
            D: "Entregar el producto para que el usuario lo pruebe."
        },
        answer: "C",
        detail: "La entrega y aceptación del sistema en su totalidad y realizar el paso a producción."
    },
    {
        question: "Métrica v.3 contempla tanto desarrollos estructurados como orientados a objetos:",
        options: {
            A: "Verdadero.",
            B: "Falso.",
            C: "Falso, es la versión 2 la que permite el doble enfoque.",
            D: "Verdadero, pudiendo variar la orientación de las técnicas en el análisis y el diseño."
        },
        answer: "D",
        detail: "Verdadero, pudiendo variar la orientación de las técnicas en el análisis y el diseño."
    },
    {
        question: "¿Cuál es un principio fundamental de MSF?",
        options: {
            A: "Establecer responsabilidades claras y compartidas.",
            B: "Adaptarse al cambio no es una prioridad.",
            C: "Centrarse en entregas que no den valor al cliente.",
            D: "Trabajar de forma individual."
        },
        answer: "A",
        detail: "Establecer responsabilidades claras y compartidas."
    },
    {
        question: "¿Cuál de las siguientes afirmaciones es correcta?",
        options: {
            A: "Las fases para el desarrollo de un proyecto en MSF son previsión, planificación, desarrollo, estabilización e implementación.",
            B: "El modelo de equipo de MSF proporciona una estructura flexible para organizar los equipos de un proyecto, asignando roles y responsabilidades a cada miembro del equipo con el objetivo de satisfacer los objetivos del proyecto.",
            C: "La disciplina de gestión de riesgos de MSF aboga por la gestión proactiva de riesgos, la evaluación continua de riesgos y la integración en la toma de decisiones durante todo el proyecto y el ciclo de vida.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "D",
        detail: "Todas las respuestas anteriores son correctas."
    },
    {
        question: "Indicar cuáles de las siguientes afirmaciones es correcta:",
        options: {
            A: "Las técnicas ágiles se adaptan muy bien a todo tipo de proyectos software.",
            B: "Las técnicas ágiles se adaptan muy bien a proyectos donde los requisitos son muy cambiantes.",
            C: "Las técnicas ágiles defienden el modelo en cascada para el desarrollo de aplicaciones.",
            D: "Todo proceso iterativo e incremental es un proceso ágil."
        },
        answer: "B",
        detail: "Las técnicas ágiles se adaptan muy bien a proyectos donde los requisitos son muy cambiantes."
    },
    {
        question: "¿En qué aspectos se asientan las técnicas ágiles para su aplicación a la hora de desarrollar software?",
        options: {
            A: "El software sale muy caro.",
            B: "Se incumplen plazos y presupuestos.",
            C: "Los requisitos del software son muy difíciles de predecir.",
            D: "El diseño y la implementación no son tareas que se realicen en paralelo."
        },
        answer: "C",
        detail: "Los requisitos del software son muy difíciles de predecir."
    },
    {
        question: "¿Cuáles de las siguientes opciones se corresponde con principios de agilidad de acuerdo al manifiesto ágil?",
        options: {
            A: "La prioridad más alta en el desarrollo de software es cumplir las necesidades del cliente a través de entregas útiles en periodos cortos.",
            B: "La prioridad más alta en el desarrollo de software es cumplir las necesidades del cliente a través de entregas que determine el cliente.",
            C: "El trabajo en equipo entre los expertos del negocio y los desarrolladores del sistema no es fundamental.",
            D: "Los desarrolladores no deben interactuar con los expertos del negocio, solamente la dirección del proyecto."
        },
        answer: "A",
        detail: "La prioridad más alta en el desarrollo de software es cumplir las necesidades del cliente a través de entregas útiles en periodos cortos."
    },
    {
        question: "¿Cuáles de las siguientes opciones se corresponden con valores a tener en cuenta cuando se desarrolle software de acuerdo al manifiesto ágil?",
        options: {
            A: "La documentación exhaustiva debería primar en todo desarrollo de software.",
            B: "El desarrollo de software útil debería primar a la documentación exhaustiva.",
            C: "Hay que dar especial importancia a los procesos y herramientas que den soporte al desarrollo ágil.",
            D: "Hay que respetar en todo momento la planificación definida para el proyecto."
        },
        answer: "B",
        detail: "El desarrollo de software útil debería primar a la documentación exhaustiva."
    },
    {
        question: "¿Qué representa la hoja de ruta en un desarrollo ágil?",
        options: {
            A: "La planificación de las diferentes iteraciones necesarias para realizar una entrega.",
            B: "La planificación de las diferentes entregas necesarias para realizar un producto software.",
            C: "Una lista de las historias de usuario que hay que implementar.",
            D: "Los productos software que comercializa una organización."
        },
        answer: "B",
        detail: "La planificación de las diferentes entregas necesarias para realizar un producto software."
    },
    {
        question: "¿Cuál es una responsabilidad del product owner en un proyecto ágil?",
        options: {
            A: "Determinar la planificación en todos los niveles de abstracción, independientemente de que el proyecto sea ágil.",
            B: "Calcular el coste total del proyecto.",
            C: "La subcontratación de personal para el proyecto.",
            D: "Fijar criterios de aceptación para cada historia de usuario."
        },
        answer: "D",
        detail: "Fijar criterios de aceptación para cada historia de usuario."
    },
    {
        question: "¿Qué es una historia de usuario?",
        options: {
            A: "La descripción de un requisito software.",
            B: "La descripción detallada de una funcionalidad que se ha de realizar en el sistema.",
            C: "La descripción del comportamiento del sistema.",
            D: "La unidad más pequeña posible de valor para el negocio."
        },
        answer: "D",
        detail: "La unidad más pequeña posible de valor para el negocio."
    },
    {
        question: "¿Qué es una epopeya?",
        options: {
            A: "Una historia de usuario de mayor tamaño y mayor funcionalidad que sigue el mismo formato que una historia de usuario, pero con mayor alcance.",
            B: "Una historia de usuario de mayor tamaño y mayor funcionalidad que sigue el mismo formato que un caso de uso.",
            C: "La descripción de un requisito software.",
            D: "La descripción de la parte de un trabajo que se ha de realizar para completar una historia de usuario."
        },
        answer: "A",
        detail: "Una historia de usuario de mayor tamaño y mayor funcionalidad que sigue el mismo formato que una historia de usuario, pero con mayor alcance."
    },
    {
        question: "A la hora de priorizar las historias de usuario, ¿qué criterios se tienen en cuenta?",
        options: {
            A: "En base al número de puntos que les hayan asignado los desarrolladores y si ha habido consenso.",
            B: "En base a la complejidad de las historias de usuario, sin considerar planificaciones iniciales.",
            C: "El valor y la estimación.",
            D: "El valor y el coste de la historia de usuario."
        },
        answer: "C",
        detail: "El valor y la estimación."
    },
    {
        question: "¿Qué es un cuadro de mando ágil?",
        options: {
            A: "Una herramienta que muestra el trabajo realizado hasta la fecha que se le indica.",
            B: "Una herramienta que muestra la lista priorizada de incidencias abiertas.",
            C: "Un tablero para definir la planificación de un proyecto ágil.",
            D: "Un tablero que agrupa métricas, gráficos y herramientas para una buena gestión del proyecto ágil."
        },
        answer: "D",
        detail: "Un tablero que agrupa métricas, gráficos y herramientas para una buena gestión del proyecto ágil."
    },
    {
        question: "Indicar cuál de las siguientes afirmaciones es correcta:",
        options: {
            A: "Scrum es una metodología que indica qué se debe hacer para su implementación con éxito en una organización.",
            B: "Scrum es un marco de trabajo que indica qué se debe hacer para su implementación con éxito en una organización.",
            C: "Scrum garantiza que la empresa que lo implemente será ágil.",
            D: "Scrum sigue los valores, pero no los principios, del manifiesto ágil."
        },
        answer: "B",
        detail: "Scrum es un marco de trabajo que indica qué se debe hacer para su implementación con éxito en una organización."
    },
    {
        question: "¿Cuáles son los errores más comunes que se dan en las organizaciones cuando se adopta scrum?",
        options: {
            A: "Excesiva documentación de los proyectos.",
            B: "Falta de empatía entre los stakeholders del proyecto.",
            C: "Presupuestar mal el proyecto software.",
            D: "El cliente es demasiado flexible con el contratista que le desarrolla el sistema."
        },
        answer: "B",
        detail: "Falta de empatía entre los stakeholders del proyecto."
    },
    {
        question: "¿Qué artefacto resulta de la reunión de planificación de un sprint?",
        options: {
            A: "El product backlog.",
            B: "El burndown chart.",
            C: "El sprint backlog.",
            D: "Ninguna de las respuestas es correcta."
        },
        answer: "C",
        detail: "El sprint backlog."
    },
    {
        question: "¿Qué responsabilidades tiene el scrum master?",
        options: {
            A: "Asegurar que todo el equipo siga las prácticas scrum.",
            B: "Dar prioridad a las funcionalidades que ha de cumplir el sistema.",
            C: "Maximizar el retorno de inversión del proyecto.",
            D: "Mejorar la calidad y productividad únicamente de la entrega final."
        },
        answer: "A",
        detail: "Asegurar que todo el equipo siga las prácticas scrum."
    },
    {
        question: "¿Qué características ha de presentar un equipo de desarrollo que adopta scrum para implementar una aplicación?",
        options: {
            A: "Multifuncional.",
            B: "Funcional.",
            C: "Claramente distribuidos.",
            D: "Jerárquico."
        },
        answer: "A",
        detail: "Multifuncional."
    },
    {
        question: "¿Cuál de las siguientes opciones no representa un rol en scrum?",
        options: {
            A: "Jefe de proyecto.",
            B: "Product owner.",
            C: "Scrum master.",
            D: "Equipo de desarrollo."
        },
        answer: "A",
        detail: "Jefe de proyecto."
    },
    {
        question: "¿Qué es el product backlog?",
        options: {
            A: "El conjunto de historias de usuario a implementar en un producto software.",
            B: "El conjunto de historias de usuario que forman parte de un sprint.",
            C: "La agrupación de las historias de usuario en base a epopeyas.",
            D: "La lista de entregas (releases) de las que está compuesto el producto software."
        },
        answer: "A",
        detail: "El conjunto de historias de usuario a implementar en un producto software."
    },
    {
        question: "¿Cuál es la diferencia básica entre un product backlog y una hoja de ruta?",
        options: {
            A: "El product backlog es más estratégico, mientras que la hoja de ruta es más táctica.",
            B: "El product backlog es más táctico, mientras que la hoja de ruta representa más la estrategia.",
            C: "La hoja de ruta muestra el trabajo pendiente a corto plazo, mientras que el product backlog tiene una visión más a futuro del software a desarrollar.",
            D: "No hay diferencias, tienen el mismo objetivo, pero a distinto nivel de abstracción."
        },
        answer: "B",
        detail: "El product backlog es más táctico, mientras que la hoja de ruta representa más la estrategia."
    },
    {
        question: "¿Qué es un sprint?",
        options: {
            A: "Las nuevas funcionalidades a añadir al producto software.",
            B: "La lista completa de funcionalidades que ha de desarrollar el producto software.",
            C: "Cada una de las iteraciones que se llevan a cabo para el desarrollo del producto software.",
            D: "El incremento que lleva cada iteración que se lleva a cabo para el desarrollo del producto software."
        },
        answer: "C",
        detail: "Cada una de las iteraciones que se llevan a cabo para el desarrollo del producto software."
    },
    {
        question: "¿Cuál es la reunión scrum en la que se presenta el trabajo realizado hasta ese momento al product owner?",
        options: {
            A: "Sprint retrospective.",
            B: "Sprint review.",
            C: "Daily scrum.",
            D: "Sprint planning."
        },
        answer: "B",
        detail: "Sprint review."
    },
    {
        question: "El ciclo de vida en XP considera las siguientes fases fundamentales:",
        options: {
            A: "Planificación, diseño, codificación y despliegue, de manera secuencial.",
            B: "Planificación, diseño, codificación y pruebas de manera solapada entre sí.",
            C: "Planificación, diseño, codificación y pruebas, de manera secuencial.",
            D: "Planificación, diseño, codificación y despliegue de manera solapada entre sí."
        },
        answer: "B",
        detail: "Planificación, diseño, codificación y pruebas de manera solapada entre sí."
    },
    {
        question: "La planificación de cada release consiste en:",
        options: {
            A: "Acatar las órdenes del jefe del proyecto que distribuye las tareas entre los programadores.",
            B: "Descomponer las historias de usuario en tareas que serán asignadas a los desarrolladores para su implementación.",
            C: "Analizar las historias de usuario para priorizarlas en función del valor que tienen desde el punto de vista del negocio.",
            D: "Un diálogo entre cliente y desarrolladores, para definir el alcance de la release seleccionando un conjunto de historias de usuario que deberán implementarse."
        },
        answer: "A",
        detail: "Acatar las órdenes del jefe del proyecto que distribuye las tareas entre los programadores."
    },
    {
        question: "¿Qué herramienta se recomienda utilizar en XP durante la fase de diseño empleando un enfoque orientado a objetos?",
        options: {
            A: "Tarjetas CRC (clase-responsabilidad-colaborador).",
            B: "Sistemas de integración continua.",
            C: "La herramienta Jira.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "A",
        detail: "Tarjetas CRC (clase-responsabilidad-colaborador)."
    },
    {
        question: "XP da importancia a la comunicación como valor fundamental, porque:",
        options: {
            A: "Permite mejorar el clima general de trabajo dentro del proyecto.",
            B: "Facilita las tareas de marketing y divulgación del nuevo desarrollo.",
            C: "Permite detectar de manera temprana posibles problemas en el proyecto.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "D",
        detail: "Todas las respuestas anteriores son correctas."
    },
    {
        question: "La técnica IXP supone una mejora sobre XP, porque:",
        options: {
            A: "Está adaptada a proyectos de organizaciones grandes, con equipos de cientos de empleados.",
            B: "Introduce nuevas prácticas, muy orientadas a aumentar la implicación de la gerencia y otros participantes de los proyectos (equipos jurídicos, marketing, etc.)",
            C: "Mejora algunas de las prácticas existentes, como la ampliación del concepto de programación en parejas a emparejamientos entre otros roles diferentes al de programador.",
            D: "Todas las respuestas son correctas."
        },
        answer: "D",
        detail: "Todas las respuestas son correctas."
    },
    {
        question: "¿Cuál es el objetivo principal de lean?",
        options: {
            A: "Reducir costes.",
            B: "Eliminar despilfarro.",
            C: "Mejorar la calidad de los productos.",
            D: "Eliminar las jerarquías verticales en las organizaciones."
        },
        answer: "B",
        detail: "Eliminar despilfarro."
    },
    {
        question: "¿Qué aspectos asociados a la documentación, de acuerdo al enfoque lean software development, se han de tener en cuenta de cara al cliente?",
        options: {
            A: "La documentación ha de ser sencilla y con un alto nivel de abstracción.",
            B: "La documentación ha de ser lo más extensa posible para que el cliente pueda tener todos los detalles del proyecto.",
            C: "La documentación siempre ha de estar disponible online para que pueda acceder a ella desde cualquier dispositivo.",
            D: "La documentación debe aportar toda la información del diseño detallado del sistema."
        },
        answer: "A",
        detail: "La documentación ha de ser sencilla y con un alto nivel de abstracción."
    },
    {
        question: "¿Cuáles son las diferencias básicas de kanban y scrum?",
        options: {
            A: "En scrum se muestra el estado del proyecto de una manera visual, mientras que en kanban no.",
            B: "En kanban se muestra el estado del proyecto de una manera visual, mientras que en scrum no.",
            C: "Kanban es menos adaptativo que scrum, lo que ofrece más posibilidades de personalización.",
            D: "Kanban incluye el pensamiento lean y scrum no."
        },
        answer: "B",
        detail: "En kanban se muestra el estado del proyecto de una manera visual, mientras que en scrum no."
    },
    {
        question: "¿Cuál de las siguientes es una diferencia clara entre XP y FDD?",
        options: {
            A: "XP es aplicable solo a desarrollos web, mientras FDD está pensada para el desarrollo de aplicaciones de escritorio.",
            B: "XP considera que la propiedad del código debe ser colectiva, mientras que en FDD cada programador se especializa en un conjunto de clases.",
            C: "XP se aplica en equipos de tamaño reducido, de menos de diez programadores, mientras que FDD es idónea para equipos de más de cincuenta personas.",
            D: "No existe ninguna diferencia significativa entre ambas técnicas."
        },
        answer: "D",
        detail: "No existe ninguna diferencia significativa entre ambas técnicas."
    },
    {
        question: "¿En qué consiste la fase de aprendizaje de la técnica ASD?",
        options: {
            A: "En estudiar el dominio de aplicación y aprender sobre él, en colaboración con el cliente, antes de comenzar el desarrollo.",
            B: "Es una fase inicial que permite a los desarrolladores adquirir conocimientos sobre una tecnología y lenguaje concretos.",
            C: "En revisar la calidad del producto desde el punto de vista del cliente y reflexionar sobre el proceso desarrollado.",
            D: "Esta no es una fase de la técnica ASD."
        },
        answer: "C",
        detail: "En revisar la calidad del producto desde el punto de vista del cliente y reflexionar sobre el proceso desarrollado."
    },
    {
        question: "¿Qué dimensiones abarca el concepto de requisito?",
        options: {
            A: "El ámbito al que va dirigido, el tipo de característica que define, la audiencia a la que va dirigido.",
            B: "La dimensión social, la dimensión humana y la dimensión de negocio.",
            C: "Los procesos, las actividades y las tareas.",
            D: "Ninguna de las respuestas anteriores es correcta."
        },
        answer: "A",
        detail: "El concepto de requisito abarca el ámbito, tipo de característica y audiencia."
    },
    {
        question: "¿Qué tipos de requisitos originan los proyectos?",
        options: {
            A: "Los requisitos funcionales, porque constituyen la especificación que guía el proceso de desarrollo.",
            B: "Los requisitos de sistema, porque pueden imponer restricciones sobre otros requisitos del software desarrollado.",
            C: "Los requisitos de negocio, porque expresan las intenciones de una organización con un nuevo desarrollo.",
            D: "Los requisitos no funcionales, porque son los más importantes."
        },
        answer: "C",
        detail: "Los requisitos de negocio expresan las intenciones de una organización."
    },
    {
        question: "¿Qué se considera requisito falso?",
        options: {
            A: "Un requisito imposible de implementar.",
            B: "Un requisito que si se implementa el sistema no cumplirá con las especificaciones.",
            C: "Un requisito que, aunque no se implemente el sistema, seguirá cumpliendo con las especificaciones.",
            D: "Un requisito dado por el cliente que luego decide cambiar."
        },
        answer: "C",
        detail: "Un requisito falso es aquel que cumple con las especificaciones aunque no se implemente."
    },
    {
        question: "Si dos actores aparecen conectados a un mismo caso de uso significa:",
        options: {
            A: "Que los dos actores representan lo mismo.",
            B: "Que los dos actores han de realizar una acción de manera simultánea para que se ejecute el caso de uso.",
            C: "Que cada actor realiza el caso de uso de manera independiente.",
            D: "Presenta ambigüedad y habría que consultar información adicional para determinar de qué manera los actores participan en el caso de uso."
        },
        answer: "D",
        detail: "La conexión de dos actores a un caso de uso puede ser ambigua."
    },
    {
        question: "Las relaciones de generalización que aparecen en un diagrama de casos de uso:",
        options: {
            A: "Indican jerarquía entre los elementos relacionados.",
            B: "Indican funcionalidad adicional del caso de uso.",
            C: "Indican el orden en el que se deben realizar los casos de uso.",
            D: "Ninguna de las anteriores definiciones es correcta."
        },
        answer: "A",
        detail: "Las generalizaciones indican jerarquía entre los elementos."
    },
    {
        question: "El modelo del sistema:",
        options: {
            A: "Incluye el modelo de análisis y el modelo de diseño del sistema.",
            B: "Modela el entorno del sistema tal y como queda una vez implementado el sistema.",
            C: "Identifica las clases, atributos y métodos del sistema a implementar en términos de la plataforma de desarrollo escogida.",
            D: "Identifica las clases, atributos y métodos del sistema a implementar en términos del dominio del negocio."
        },
        answer: "C",
        detail: "El modelo del sistema identifica clases, atributos y métodos en términos de la plataforma de desarrollo."
    },
    {
        question: "El modelo del entorno:",
        options: {
            A: "Modela el negocio tal y como va a quedar una vez se haya implementado el sistema.",
            B: "Identifica las clases, atributos y operaciones del sistema a implementar en términos del dominio.",
            C: "Identifica las clases, atributos y métodos del sistema a implementar en términos de la plataforma de desarrollo escogida.",
            D: "Modela la parte de la realidad que rodea al sistema informático y con la que este interactúa para proporcionarle determinados servicios."
        },
        answer: "D",
        detail: "El modelo del entorno describe la realidad que interactúa con el sistema."
    },
    {
        question: "¿Qué define la ley de Demeter?",
        options: {
            A: "La ley de Demeter define el conjunto de operaciones que se dan entre las clases en un sistema concreto.",
            B: "La ley de Demeter define las restricciones de comunicación entre objetos que se dan en el sistema.",
            C: "La ley de Demeter define que un objeto no se puede mandar mensajes a sí mismo si no tiene definida una asociación reflexiva.",
            D: "La ley de Demeter no define a qué instancias puede enviar mensajes un objeto de una clase."
        },
        answer: "B",
        detail: "La ley de Demeter establece restricciones en la comunicación entre objetos."
    },
    {
        question: "El polimorfismo de mensajes significa:",
        options: {
            A: "Que distintos objetos pueden actuar de manera distinta ante el mismo mensaje.",
            B: "Que distintos objetos pueden invocar una operación con el mismo nombre, pero con diferente número de parámetros definidos en cada operación.",
            C: "Que un objeto puede enviar varios mensajes a la vez.",
            D: "Que distintos objetos de distintas clases comparten una misma interfaz."
        },
        answer: "A",
        detail: "El polimorfismo permite a distintos objetos reaccionar de manera diferente al mismo mensaje."
    },
    {
        question: "¿Qué se considera componente desde el punto de vista de modelado de software?",
        options: {
            A: "Una unidad reutilizable persistente.",
            B: "Una unidad compuesta de objetos.",
            C: "Una unidad de «despliegue» independiente que se puede reutilizar y reemplazar.",
            D: "Una unidad que proporciona alta cohesión y un alto acoplamiento."
        },
        answer: "C",
        detail: "Un componente es una unidad de despliegue independiente que puede ser reutilizada."
    },
    {
        question: "En la programación orientada a objetos:",
        options: {
            A: "Las clases heredan atributos y operaciones de los objetos.",
            B: "El software se organiza en forma de objetos, pero no siempre serán instancia de una clase.",
            C: "Los elementos principales son los algoritmos que definen los objetos.",
            D: "Las clases se organizan en jerarquías a través de la herencia."
        },
        answer: "D",
        detail: "Las clases en programación orientada a objetos se organizan mediante herencia."
    },
    {
        question: "¿Qué afirmación satisface todo lenguaje orientado a objetos?",
        options: {
            A: "Las clases son de un tipo concreto.",
            B: "Los objetos son de un tipo concreto.",
            C: "Las clases no pueden heredar atributos de sus superclases.",
            D: "Las clases siempre tendrán atributos y operaciones."
        },
        answer: "D",
        detail: "En un lenguaje orientado a objetos, las clases siempre tienen atributos y operaciones."
    },
    {
        question: "El análisis orientado a objetos (AOO):",
        options: {
            A: "Define las clases que servirán siempre de base para el diseño orientado a objetos (DOO).",
            B: "Define las clases que se traducirán siempre automáticamente en una clase de diseño.",
            C: "En realidad no es un análisis del sistema.",
            D: "Ninguna de las anteriores definiciones es correcta."
        },
        answer: "A",
        detail: "El AOO establece clases que son fundamentales para el diseño orientado a objetos."
    },
    {
        question: "Un sistema debería enfocarse con una orientación a objetos siempre que:",
        options: {
            A: "Se quiera reutilizar.",
            B: "El mundo real en el que está basado esté formado por objetos.",
            C: "Haya una colaboración de objetos.",
            D: "Siempre hay que utilizar la orientación a objetos para desarrollar sistemas, es lo más eficiente."
        },
        answer: "C",
        detail: "La orientación a objetos es adecuada cuando hay colaboración entre objetos."
    },
    {
        question: "¿Cuál de las siguientes afirmaciones no es correcta?",
        options: {
            A: "UML es un lenguaje visual.",
            B: "UML modela las vistas estática y dinámica de los sistemas.",
            C: "UML es un lenguaje solo válido para un tipo de dominios.",
            D: "UML es un lenguaje de propósito general."
        },
        answer: "C",
        detail: "UML es un lenguaje de propósito general y no se limita a un solo tipo de dominio."
    },
    {
        question: "¿Cuál de las siguientes afirmaciones es correcta?",
        options: {
            A: "Un objeto puede que no tenga tipo.",
            B: "Un objeto es una instancia de una clase.",
            C: "Cuando dos objetos tienen los mismos valores en los atributos es porque son iguales.",
            D: "Los objetos se comunican con otros objetos a través del envío de mensajes solo si son instancias de la misma clase."
        },
        answer: "B",
        detail: "Un objeto es efectivamente una instancia de una clase."
    },
    {
        question: "¿Cuál de las siguientes afirmaciones es correcta?",
        options: {
            A: "Una clase representa un conjunto de objetos tangibles.",
            B: "Una clase recoge las características y el comportamiento comunes de un conjunto de objetos.",
            C: "Una clase no puede heredar de varias clases, solo de una.",
            D: "Una clase no define la comunicación con otras clases, eso se define a nivel de objeto."
        },
        answer: "B",
        detail: "Una clase define características y comportamientos comunes de objetos."
    },
    {
        question: "La identidad de un objeto viene definida por:",
        options: {
            A: "La información del objeto en el mundo real que le identifica de manera unívoca.",
            B: "El atributo identificador de la clase.",
            C: "La clase a la que pertenece.",
            D: "Cuando la clase a la que pertenece hereda de otra clase, entonces tiene varias identidades."
        },
        answer: "A",
        detail: "La identidad se define por la información única del objeto en el mundo real."
    },
    {
        question: "El comportamiento de una clase viene definido por:",
        options: {
            A: "Las operaciones que se hayan definido en la clase.",
            B: "Los estados por los que puede pasar la clase.",
            C: "Las responsabilidades que tenga definidas.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "D",
        detail: "El comportamiento de una clase se define por operaciones, estados y responsabilidades."
    },
    {
        question: "Las herramientas CASE:",
        options: {
            A: "Solo son válidas para introducir código.",
            B: "Facilitan la extracción de requisitos.",
            C: "No facilitan la ingeniería de requisitos.",
            D: "Transforman la especificación del sistema software en una especificación específica para la plataforma de desarrollo seleccionada."
        },
        answer: "D",
        detail: "Las herramientas CASE transforman especificaciones en formatos para plataformas específicas."
    },
    {
        question: "En la programación orientada a objetos:",
        options: {
            A: "Las clases heredan atributos y operaciones de los objetos.",
            B: "El software se organiza en forma de objetos, pero no siempre serán instancia de una clase.",
            C: "Los elementos principales son los algoritmos que definen los objetos.",
            D: "Las clases se organizan en jerarquías a través de la herencia."
        },
        answer: "D",
        detail: "Las clases se organizan en jerarquías a través de la herencia."
    },
    {
        question: "¿Qué afirmación satisface todo lenguaje orientado a objetos?",
        options: {
            A: "Las clases son de un tipo concreto.",
            B: "Los objetos son de un tipo concreto.",
            C: "Las clases no pueden heredar atributos de sus superclases.",
            D: "Las clases siempre tendrán atributos y operaciones."
        },
        answer: "D",
        detail: "Las clases siempre tendrán atributos y operaciones."
    },
    {
        question: "El análisis orientado a objetos (AOO):",
        options: {
            A: "Define las clases que servirán siempre de base para el diseño orientado a objetos.",
            B: "Define las clases que se traducirán siempre automáticamente en una clase de diseño.",
            C: "En realidad no es un análisis del sistema.",
            D: "Ninguna de las anteriores definiciones es correcta."
        },
        answer: "A",
        detail: "Define las clases que servirán siempre de base para el diseño orientado a objetos."
    },
    {
        question: "Un sistema debería enfocarse con una orientación a objetos siempre que:",
        options: {
            A: "Se quiera reutilizar.",
            B: "El mundo real en el que está basado esté formado por objetos.",
            C: "Haya una colaboración de objetos.",
            D: "Siempre hay que utilizar la orientación a objetos para desarrollar sistemas, es lo más eficiente."
        },
        answer: "C",
        detail: "Haya una colaboración de objetos."
    },
    {
        question: "¿Cuál de las siguientes afirmaciones no es correcta?",
        options: {
            A: "UML es un lenguaje visual.",
            B: "UML modela las vistas estática y dinámica de los sistemas.",
            C: "UML es un lenguaje solo válido para un tipo de dominios.",
            D: "UML es un lenguaje de propósito general."
        },
        answer: "C",
        detail: "UML es un lenguaje solo válido para un tipo de dominios."
    },
    {
        question: "¿Cuál de las siguientes afirmaciones es correcta?",
        options: {
            A: "Un objeto puede que no tenga tipo.",
            B: "Un objeto es una instancia de una clase.",
            C: "Cuando dos objetos tienen los mismos valores en los atributos es porque son iguales.",
            D: "Los objetos se comunican con otros objetos a través del envío de mensajes solo si son instancias de la misma clase."
        },
        answer: "B",
        detail: "Un objeto es una instancia de una clase."
    },
    {
        question: "¿Cuál de las siguientes afirmaciones es correcta?",
        options: {
            A: "Una clase representa un conjunto de objetos tangibles.",
            B: "Una clase recoge las características y el comportamiento comunes de un conjunto de objetos.",
            C: "Una clase no puede heredar de varias clases, solo de una.",
            D: "Una clase no define la comunicación con otras clases, eso se define a nivel de objeto."
        },
        answer: "B",
        detail: "Una clase recoge las características y el comportamiento comunes de un conjunto de objetos."
    },
    {
        question: "La identidad de un objeto viene definida por:",
        options: {
            A: "La información del objeto en el mundo real que le identifica de manera unívoca.",
            B: "El atributo identificador de la clase.",
            C: "La clase a la que pertenece.",
            D: "Cuando la clase a la que pertenece hereda de otra clase, entonces tiene varias identidades."
        },
        answer: "A",
        detail: "La información del objeto en el mundo real que le identifica de manera unívoca."
    },
    {
        question: "El comportamiento de una clase viene definido por:",
        options: {
            A: "Las operaciones que se hayan definido en la clase.",
            B: "Los estados por los que puede pasar la clase.",
            C: "Las responsabilidades que tenga definidas.",
            D: "Todas son correctas."
        },
        answer: "D",
        detail: "Todas son correctas."
    },
    {
        question: "Las herramientas CASE:",
        options: {
            A: "Solo son válidas para introducir código.",
            B: "Facilitan la extracción de requisitos.",
            C: "No facilitan la ingeniería de requisitos.",
            D: "Transforman la especificación del sistema software en una especificación específica para la plataforma de desarrollo seleccionada."
        },
        answer: "D",
        detail: "Transforman la especificación del sistema software en una especificación específica para la plataforma de desarrollo seleccionada."
    },
    {
        question: "¿Qué diferencia hay entre un enfoque basado en modelos y un enfoque dirigido por modelos a la hora de desarrollar software?",
        options: {
            A: "No hay diferencia, son términos sinónimos.",
            B: "El enfoque dirigido por modelos utiliza los modelos básicamente como documentación o para entender mejor un determinado problema, mientras que, en el enfoque basado en modelos, los modelos constituyen los artefactos del software.",
            C: "El enfoque basado en modelos utiliza los modelos básicamente como documentación o para entender mejor un determinado problema, mientras que, en el enfoque dirigido por modelos, los modelos constituyen los artefactos del software.",
            D: "El enfoque basado en modelos solo utiliza modelos en la extracción de requisitos, mientras que el enfoque dirigido por modelos utiliza los modelos en todas las fases del proceso de desarrollo de software."
        },
        answer: "C",
        detail: "El enfoque basado en modelos utiliza los modelos básicamente como documentación o para entender mejor un determinado problema, mientras que, en el enfoque dirigido por modelos, los modelos constituyen los artefactos del software."
    },
    {
        question: "¿Cuáles son los fundamentos de MDE?",
        options: {
            A: "MDE se fundamenta en tres conceptos y en dos relaciones.",
            B: "MDE se fundamenta en que los modelos sirven como documentación del sistema.",
            C: "MDE se fundamenta en los siguientes elementos: sistema, modelo, representación y conformidad.",
            D: "MDE se fundamenta en los principios básicos de la OO."
        },
        answer: "C",
        detail: "MDE se fundamenta en los siguientes elementos: sistema, modelo, representación y conformidad."
    },
    {
        question: "¿Qué es un modelo?",
        options: {
            A: "Una representación gráfica del sistema.",
            B: "Una ilustración simplificada del sistema.",
            C: "Una estructura basada en un grafo (dirigido y etiquetado) que representa todo un sistema.",
            D: "Una estructura basada en un grafo (dirigido y etiquetado) que representa un conjunto específico de incumbencias."
        },
        answer: "D",
        detail: "Una estructura basada en un grafo (dirigido y etiquetado) que representa un conjunto específico de incumbencias."
    },
    {
        question: "¿Qué es un metamodelo?",
        options: {
            A: "Un modelo que cubre todas las vistas del sistema.",
            B: "Un modelo que proporciona un esquema de «tipos» para los elementos del modelo.",
            C: "Un lenguaje de modelado.",
            D: "Un lenguaje de dominio específico."
        },
        answer: "B",
        detail: "Un modelo que proporciona un esquema de «tipos» para los elementos del modelo."
    },
    {
        question: "¿Cuáles son las tres dimensiones de modelado definidas en MDA?",
        options: {
            A: "PSG, PIM y PSM.",
            B: "CIM, PSG y PSM.",
            C: "CIM, PIM y PSM.",
            D: "CIM, PMM y PSM."
        },
        answer: "C",
        detail: "CIM, PIM y PSM."
    },
    {
        question: "De acuerdo al enfoque de ingeniería dirigida por modelos:",
        options: {
            A: "Un modelo es conforme a un metamodelo.",
            B: "Un modelo es instancia de un metamodelo.",
            C: "Un modelo es conforme a varios metamodelos.",
            D: "Un modelo y el sistema son equivalentes."
        },
        answer: "A",
        detail: "Un modelo es conforme a un metamodelo."
    },
    {
        question: "La separación en vistas del sistema:",
        options: {
            A: "Aumenta la complejidad del sistema y favorece la comprensión del sistema.",
            B: "Reduce la complejidad del sistema, pero no favorece la reutilización.",
            C: "No permite cambios en el software, ni facilita la evolución del software.",
            D: "Favorece la reutilización y la trazabilidad entre los distintos artefactos del sistema."
        },
        answer: "D",
        detail: "Favorece la reutilización y la trazabilidad entre los distintos artefactos del sistema."
    },
    {
        question: "¿Qué es OCL?",
        options: {
            A: "Un lenguaje informal que permite añadir información adicional a los modelos UML.",
            B: "Un lenguaje gráfico que permite añadir restricciones a los modelos UML.",
            C: "Un lenguaje textual que permite añadir restricciones a los modelos UML.",
            D: "Un lenguaje formal y textual que solo permite especificar restricciones sobre el sistema modelado."
        },
        answer: "C",
        detail: "Un lenguaje textual que permite añadir restricciones a los modelos UML."
    },
    {
        question: "¿Qué se entiende por M2M?",
        options: {
            A: "Un programa que toma uno o más modelos como entrada y produce uno o más modelos como salida.",
            B: "Transformar modelos a un mismo nivel de abstracción.",
            C: "Una técnica que se da en el enfoque MDA, pero no en el enfoque MDE.",
            D: "Una técnica que consiste en código fuente a partir de un modelo de entrada."
        },
        answer: "A",
        detail: "Un programa que toma uno o más modelos como entrada y produce uno o más modelos como salida."
    },
    {
        question: "¿Qué se entiende por M2T?",
        options: {
            A: "Generar la documentación del sistema a partir de los modelos generados para implementar el sistema.",
            B: "Establecer un enlace de comunicación entre herramientas de análisis, pero no con plataformas de ejecución.",
            C: "Generar un código fuente a partir de los modelos generados para implementar el sistema.",
            D: "Definir casos de prueba a partir de los modelos generados para implementar el sistema."
        },
        answer: "C",
        detail: "Generar un código fuente a partir de los modelos generados para implementar el sistema."
    },
    {
        question: "¿Qué entendemos por reutilización del software?",
        options: {
            A: "La reutilización de código generado en proyectos anteriores en nuevos desarrollos.",
            B: "La utilización de patrones de diseño y de arquitectura que proporcionan conocimiento acumulado en proyectos anteriores.",
            C: "El empleo de librerías existentes o frameworks de desarrollo en la construcción de nuevos sistemas informáticos.",
            D: "Todas son correctas."
        },
        answer: "D",
        detail: "Todas son correctas."
    },
    {
        question: "¿Qué ventajas ofrece un buen diseño arquitectónico?",
        options: {
            A: "Permite reutilizar conocimiento acumulado por expertos en proyectos anteriores.",
            B: "Permite analizar mejor el sistema e identificar oportunidades de reutilización de componentes existentes.",
            C: "Constituye una potente herramienta de documentación del sistema que ayuda a su comprensión.",
            D: "Todas son correctas."
        },
        answer: "D",
        detail: "Todas son correctas."
    },
    {
        question: "¿Qué posibles problemas puede plantear el empleo de librerías de enlace dinámico?",
        options: {
            A: "Problemas de compatibilidad cuando tenemos varios programas que dependen de una misma librería, pero necesitan distintas versiones.",
            B: "Problemas que dificultan la comprensión del código.",
            C: "Ambas son correctas.",
            D: "Ninguna es correcta."
        },
        answer: "A",
        detail: "Problemas de compatibilidad cuando tenemos varios programas que dependen de una misma librería, pero necesitan distintas versiones."
    },
    {
        question: "¿Qué dos tipos de interfaz ofrece un componente software?",
        options: {
            A: "Una interfaz pública y una interfaz privada.",
            B: "Ofrecen siempre una interfaz «proporciona» y una interfaz «requiere».",
            C: "Una interfaz pública y otra interfaz que ofrece servicios.",
            D: "Una interfaz «proporciona» y, a veces, una interfaz «requiere»."
        },
        answer: "B",
        detail: "Ofrecen siempre una interfaz «proporciona» y una interfaz «requiere»."
    },
    {
        question: "¿Qué entendemos como un «cliente pesado»?",
        options: {
            A: "Aquel que se conecta con un servidor empleando protocolos antiguos no estandarizados.",
            B: "Aquel que solo contiene la capa de presentación de datos al usuario y ofrece interactividad con el sistema.",
            C: "Un cliente que solo puede ejecutarse en PC de escritorio, pero no en dispositivos más ligeros como tabletas y móviles.",
            D: "Un cliente que, además de contener la capa de presentación, contiene lógica de negocio y almacena y manipula datos."
        },
        answer: "D",
        detail: "Un cliente que, además de contener la capa de presentación, contiene lógica de negocio y almacena y manipula datos."
    },
    {
        question: "¿Cuándo es apropiado emplear arquitecturas de repositorio?",
        options: {
            A: "Cuando es necesario procesar grandes cantidades de información en lote, realizando varios tipos de procesamiento.",
            B: "Cuando es necesario almacenar grandes cantidades de información durante mucho tiempo, que es consumida, o generada, por un conjunto de clientes.",
            C: "Cuando es necesario establecer diferentes niveles de acceso a un sistema de información.",
            D: "Todas son correctas."
        },
        answer: "B",
        detail: "Cuando es necesario almacenar grandes cantidades de información durante mucho tiempo, que es consumida, o generada, por un conjunto de clientes."
    },
    {
        question: "¿Qué ventajas ofrecen los sistemas distribuidos frente a los centralizados?",
        options: {
            A: "Es más fácil compartir recursos entre diferentes subsistemas.",
            B: "Ambas son correctas.",
            C: "Permiten la concurrencia, al poder ejecutar procesos simultáneamente en varias máquinas.",
            D: "Ninguna es correcta."
        },
        answer: "B",
        detail: "Ambas son correctas."
    },
    {
        question: "¿En qué tres categorías suelen agruparse los patrones de diseño?",
        options: {
            A: "Creacionales, estructurales y conductuales.",
            B: "Creativos, estructurales y de comportamiento.",
            C: "Adaptativos, compuestos y mediadores.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "A",
        detail: "Creacionales, estructurales y conductuales."
    },
    {
        question: "¿Qué patrón se debería utilizar cuando se necesite resolver interfaces incompatibles o proporcionar una interfaz estable para componentes parecidos con diferentes interfaces?",
        options: {
            A: "Adapter.",
            B: "Strategy.",
            C: "Singleton.",
            D: "Observer."
        },
        answer: "A",
        detail: "Adapter."
    },
    {
        question: "¿Qué patrón se debería utilizar cuando un objeto necesite enterarse de cambios en otro objeto?",
        options: {
            A: "Adapter.",
            B: "Observer.",
            C: "Strategy.",
            D: "Composite."
        },
        answer: "B",
        detail: "Observer."
    },
    {
        question: "¿De qué se encargan las técnicas de validación del software?",
        options: {
            A: "De comprobar la correcta especificación de requisitos según las necesidades del usuario.",
            B: "De garantizar que el sistema final cumple con las expectativas del cliente o usuario.",
            C: "De responder a la pregunta «¿estamos construyendo el sistema correcto?»,",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "D",
        detail: "Todas las respuestas anteriores son correctas."
    },
    {
        question: "¿Cuál es el objetivo principal de las pruebas del sistema?",
        options: {
            A: "Comprobar la corrección funcional de las capacidades implementadas.",
            B: "Comprobar el correcto funcionamiento del sistema en un entorno operativo real, con especial atención a los requisitos no funcionales.",
            C: "Garantizar la adecuación del sistema a las necesidades del cliente.",
            D: "Comprobar la correcta interacción entre componentes del sistema en el entorno de desarrollo."
        },
        answer: "B",
        detail: "Comprobar el correcto funcionamiento del sistema en un entorno operativo real, con especial atención a los requisitos no funcionales."
    },
    {
        question: "¿Cuál de las siguientes pruebas se parece más a una prueba de aceptación?",
        options: {
            A: "Una prueba de validación de tipo alfa.",
            B: "Una prueba unitaria.",
            C: "Una prueba de validación de tipo beta.",
            D: "Una prueba de integración entre todos los componentes del sistema."
        },
        answer: "C",
        detail: "Una prueba de validación de tipo beta se asemeja más a una prueba de aceptación."
    },
    {
        question: "¿Cuál de las siguientes es una ventaja del enfoque de desarrollo TDD?",
        options: {
            A: "i) Ayuda a construir código que se comprueba de manera automática.",
            B: "ii) Aumenta la productividad de los equipos de desarrollo.",
            C: "iii) Ayuda a mejorar el diseño del producto, aunque no haya una fase específica dedicada a ello.",
            D: "i) y iii) son correctas."
        },
        answer: "D",
        detail: "i) y iii) son correctas."
    },
    {
        question: "¿En qué consiste el patrón AAA dentro de la técnica TDD?",
        options: {
            A: "En escribir los test teniendo en cuenta los intereses del usuario final.",
            B: "En definir las pruebas teniendo en cuenta las acciones esperadas por parte del usuario.",
            C: "En diseñar cada nuevo módulo antes de proceder a su implementación.",
            D: "En estructurar las pruebas comenzando por la definición de parámetros de entrada, colocar luego las acciones a ejecutar y, finalmente, comprobar los resultados esperados."
        },
        answer: "D",
        detail: "En estructurar las pruebas comenzando por la definición de parámetros de entrada, colocar luego las acciones a ejecutar y, finalmente, comprobar los resultados esperados."
    },
    {
        question: "¿Qué beneficios aporta la técnica de desarrollo ATDD sobre TDD?",
        options: {
            A: "i) Garantiza que el sistema no será finalizado hasta que se verifiquen todas las pruebas de aceptación.",
            B: "ii) Ayuda a modelar las pruebas desde el punto de vista de los resultados esperados por el cliente.",
            C: "iii) Involucra en el proceso de desarrollo y pruebas a un número mayor de stakeholders.",
            D: "i) y ii) son correctas."
        },
        answer: "D",
        detail: "i) y ii) son correctas."
    },
    {
        question: "Cuando empleamos un enfoque de desarrollo dirigido por las pruebas, esto significa que:",
        options: {
            A: "Debemos definir todas las pruebas al comienzo del desarrollo del sistema.",
            B: "Debemos escribir las pruebas inmediatamente después de finalizar la fase de diseño.",
            C: "Debemos emplear obligatoriamente un framework apropiado que ayude a automatizar las pruebas.",
            D: "Ninguna de las respuestas anteriores es correcta."
        },
        answer: "D",
        detail: "Ninguna de las respuestas anteriores es correcta."
    },
    {
        question: "¿Qué tres enfoques del concepto de calidad se contemplan en las normas ISO/IEC 9126 y en la ISO/IEC 25000?",
        options: {
            A: "Calidad inherente, calidad intrínseca y calidad medible.",
            B: "Calidad interna, calidad del proceso y calidad externa.",
            C: "Calidad interna, calidad externa y calidad en uso.",
            D: "Ninguna de las respuestas anteriores es correcta."
        },
        answer: "C",
        detail: "Calidad interna, calidad externa y calidad en uso."
    },
    {
        question: "¿Qué factores afectan a la calidad del producto software?",
        options: {
            A: "La cualificación del equipo de desarrollo.",
            B: "La calidad de los procesos empleados.",
            C: "La tecnología utilizada en los procesos.",
            D: "Todas las respuestas anteriores son correctas."
        },
        answer: "D",
        detail: "Todas las respuestas anteriores son correctas."
    },
    {
        question: "¿Qué es CMMI?",
        options: {
            A: "Una metodología de desarrollo de software.",
            B: "Un modelo de proceso tradicional.",
            C: "Un modelo de madurez de procesos.",
            D: "Una metodología para evaluar la calidad de los procesos."
        },
        answer: "C",
        detail: "CMMI es un modelo de madurez de procesos."
    },
    {
        question: "¿Qué es CMMI?",
        options: {
            A: "Una metodología de desarrollo de software.",
            B: "Un modelo de proceso tradicional.",
            C: "Un modelo de madurez de procesos.",
            D: "Una metodología para evaluar la calidad de los procesos."
        },
        answer: "C",
        detail: "CMMI es un modelo de madurez de procesos."
    },
    {
        question: "¿Qué significa MDA en el desarrollo de software?",
        options: {
            A: "Modelo de Datos Avanzado.",
            B: "Arquitectura Dirigida por Modelos.",
            C: "Método de Desarrollo Ágil.",
            D: "Modelo de Análisis de Datos."
        },
        answer: "B",
        detail: "MDA significa Arquitectura Dirigida por Modelos, un enfoque que utiliza modelos para generar software."
    },
    {
        question: "¿Qué es un Lenguaje Específico de Dominio (DSL)?",
        options: {
            A: "Un lenguaje de programación general.",
            B: "Un lenguaje adaptado a un dominio particular.",
            C: "Un lenguaje para definir requisitos.",
            D: "Un lenguaje de consulta de bases de datos."
        },
        answer: "B",
        detail: "Un DSL es un lenguaje adaptado a un dominio particular, facilitando la expresión de soluciones específicas."
    },
    {
        question: "¿Cuál es la función principal de OCL?",
        options: {
            A: "Definir flujos de trabajo.",
            B: "Especificar restricciones en modelos.",
            C: "Crear diagramas gráficos.",
            D: "Generar código automáticamente."
        },
        answer: "B",
        detail: "OCL se utiliza para especificar restricciones y condiciones en modelos orientados a objetos."
    },
    {
        question: "¿Qué representa la verificación en el desarrollo de software?",
        options: {
            A: "Evaluar la satisfacción del cliente.",
            B: "Asegurar que el software se construya según los requisitos.",
            C: "Realizar pruebas de usabilidad.",
            D: "Confirmar el rendimiento del software."
        },
        answer: "B",
        detail: "La verificación implica asegurar que el software se construya de acuerdo con los requisitos y especificaciones."
    },
    {
        question: "¿Qué es una transformación M2M?",
        options: {
            A: "Transformación de un modelo a otro modelo.",
            B: "Transformación de un modelo a código fuente.",
            C: "Transformación de código a un modelo.",
            D: "Transformación de texto a un modelo."
        },
        answer: "A",
        detail: "M2M se refiere a la transformación de un modelo en otro modelo, manteniendo la estructura y significado."
    },
    {
        question: "¿Cuál es el propósito de las pruebas de aceptación del usuario?",
        options: {
            A: "Asegurar que el software cumple con los requisitos técnicos.",
            B: "Confirmar que el software satisface las necesidades del usuario.",
            C: "Verificar el rendimiento del software bajo carga.",
            D: "Validar la calidad del código fuente."
        },
        answer: "B",
        detail: "Las pruebas de aceptación del usuario se realizan para confirmar que el software satisface las necesidades y expectativas del usuario."
    },
    {
        question: "¿Qué es un modelo de negocio en el contexto de MDA?",
        options: {
            A: "Un enfoque ágil para el desarrollo.",
            B: "Un tipo de software de gestión.",
            C: "Un modelo que describe cómo se genera valor.",
            D: "Un modelo para definir la arquitectura técnica."
        },
        answer: "C",
        detail: "Un modelo de negocio describe cómo se genera y entrega valor a los clientes."
    },
    {
        question: "¿Qué tipo de transformaciones son M2T?",
        options: {
            A: "Modelo a Modelo.",
            B: "Modelo a Texto.",
            C: "Texto a Modelo.",
            D: "Modelo a Diagramas."
        },
        answer: "B",
        detail: "M2T se refiere a la transformación de un modelo a un formato textual, como código fuente."
    },
    {
        question: "¿Cuál es una herramienta comúnmente utilizada para las transformaciones de modelos?",
        options: {
            A: "Photoshop.",
            B: "Eclipse Modeling Framework (EMF).",
            C: "Microsoft Word.",
            D: "AutoCAD."
        },
        answer: "B",
        detail: "Eclipse Modeling Framework (EMF) es comúnmente utilizado para crear y transformar modelos."
    },
    {
        question: "En el contexto de OCL, ¿qué es una 'invariante'?",
        options: {
            A: "Una condición que debe mantenerse verdadera en un modelo.",
            B: "Un tipo de dato específico.",
            C: "Una función de transformación.",
            D: "Un error en el modelo."
        },
        answer: "A",
        detail: "Una 'invariante' es una condición que debe mantenerse verdadera en un modelo a lo largo de su ciclo de vida."
    },
    {
        question: "¿Qué es la validación en el desarrollo de software?",
        options: {
            A: "Asegurar que el software cumpla con las especificaciones.",
            B: "Evaluar si el software satisface las necesidades del usuario.",
            C: "Realizar pruebas de rendimiento.",
            D: "Verificar el código fuente."
        },
        answer: "B",
        detail: "La validación evalúa si el software satisface las necesidades y expectativas del usuario final."
    },
    {
        question: "¿Qué herramienta se puede usar para generar código a partir de un modelo?",
        options: {
            A: "Un procesador de texto.",
            B: "Un generador de código basado en plantillas.",
            C: "Una hoja de cálculo.",
            D: "Un software de diseño gráfico."
        },
        answer: "B",
        detail: "Un generador de código basado en plantillas convierte un modelo en código fuente."
    },
    {
        question: "¿Qué es un caso de uso en el contexto de desarrollo de software?",
        options: {
            A: "Un documento de requisitos.",
            B: "Una técnica de programación.",
            C: "Una descripción de cómo los usuarios interactúan con el sistema.",
            D: "Un modelo de datos."
        },
        answer: "C",
        detail: "Un caso de uso describe cómo los usuarios interactúan con el sistema para lograr un objetivo específico."
    },
    {
        question: "¿Cuál es el objetivo principal de las pruebas unitarias?",
        options: {
            A: "Probar la aplicación completa.",
            B: "Verificar el rendimiento del sistema.",
            C: "Asegurar que cada unidad de código funcione correctamente.",
            D: "Validar la interfaz de usuario."
        },
        answer: "C",
        detail: "Las pruebas unitarias aseguran que cada unidad de código funcione correctamente de manera aislada."
    },
    {
        question: "¿Qué es una arquitectura de software?",
        options: {
            A: "Un modelo de datos.",
            B: "La estructura y organización de un sistema de software.",
            C: "Un tipo de lenguaje de programación.",
            D: "Un enfoque para la gestión de proyectos."
        },
        answer: "B",
        detail: "La arquitectura de software es la estructura y organización de un sistema de software, incluyendo sus componentes y relaciones."
    },
    {
        question: "¿Qué es el análisis de requisitos?",
        options: {
            A: "La fase de diseño del software.",
            B: "La identificación y documentación de las necesidades del cliente.",
            C: "Un tipo de prueba de software.",
            D: "La implementación del código."
        },
        answer: "B",
        detail: "El análisis de requisitos implica identificar y documentar las necesidades del cliente para el software."
    },
    {
        question: "¿Cuál es un beneficio de usar DSL en el desarrollo de software?",
        options: {
            A: "Aumenta la complejidad del código.",
            B: "Facilita la comunicación con los expertos del dominio.",
            C: "Reduce la necesidad de pruebas.",
            D: "Elimina la necesidad de documentación."
        },
        answer: "B",
        detail: "El uso de un DSL facilita la comunicación con los expertos del dominio al utilizar un lenguaje adaptado a sus necesidades."
    }
];